sql优化：
1、关于JOIN优化
LEFT JOIN A表为驱动表，INNER JOIN MySQL会自动找出那个
数据少的表作用驱动表，RIGHT JOIN B表为驱动表。

1）尽量使用inner join，避免left join：
参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，
在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱
动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。

2）利用小表去驱动大表：
从原理图能够直观的看出如果能够减少驱动表的话，减少嵌套循环中
的循环次数，以减少 IO总量及CPU运算的次数。


2、避免在where子句中对字段进行表达式操作
比如：
select user_id,user_project from user_base where age*2=36;
中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成：
select user_id,user_project from user_base where age=36/2;


3、避免在where子句中对字段进行null值判断
对于null的判断会导致引擎放弃使用索引而进行全表扫描。


4、使用合理的分页方式以提高分页的效率
select id,name from product limit 866613, 20
使用上述SQL语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。
优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，
上一页最大的id是866612。SQL可以采用如下的写法：
select id,name from product where id> 866612 limit 20


5、尽量用union all代替union
union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，
这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all
的前提条件是两个结果集没有重复数据。


6、如果限制条件中其他字段没有索引，尽量少用or
or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查
询不走索引的情况。很多时候使用union all或者是union（必要的时候）的方式来
代替“or”会得到更好的效果。


3、SELECT语句务必指明字段名称
SELECT*增加很多不必要的消耗（CPU、IO、内存、网络带宽）；增加了使用覆盖索引的
可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。


2、SQL语句中IN包含的值不应过多
MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组
是排好序的。但是如果数值较多，产生的消耗也是比较大的。再
例如：select id from t where num in(1,2,3) 对于连续的数值，能用between就
不要用in了；再或者使用连接来替换。
